{"version":3,"sources":["EncryptedStorage.ts"],"names":["randomKey","pbkdf2","encryptData","decryptData","SecureKeyStore","ACCOUNT_KEY_PREFIX","ACCOUNT_KEY","account","EncryptedStorage","constructor","storage","key","dataKey","setAccount","passphrase","get","err","undefined","salt","set","setItem","value","encryptedData","JSON","stringify","setItemT","getItem","encryptedDataStr","parse","cypher","getItemT","defaultValue","itemStr","removeItem"],"mappings":"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","sourcesContent":["import {\n  randomKey,\n  pbkdf2,\n  encryptData,\n  decryptData,\n  EncryptedData,\n} from './crypto-utils'\nimport * as SecureKeyStore from './secure-keystore'\n\nconst ACCOUNT_KEY_PREFIX = '@rn-encrypted-storage:key'\nconst ACCOUNT_KEY = (account: string) => `${ACCOUNT_KEY_PREFIX}:${account}`\n\nexport class EncryptedStorage implements StorageInterface {\n  private account: string\n  private key: string\n  private storage: StorageInterface | null\n\n  constructor(storage: StorageInterface) {\n    this.account = ''\n    this.key = ''\n    this.storage = storage\n  }\n\n  private dataKey(key: string) {\n    return `${ACCOUNT_KEY(this.account)}/${key}`\n  }\n\n  async setAccount(account: string, passphrase: string): Promise<string> {\n    this.account = account\n\n    // get key from store\n    let key\n    try {\n      key = await SecureKeyStore.get(ACCOUNT_KEY(account))\n    } catch (err) {\n      // ignore this error\n      key = undefined\n    }\n\n    if (!key) {\n      const salt = await randomKey(32)\n      key = await pbkdf2(passphrase, salt, 5000, 256)\n      // store key\n      await SecureKeyStore.set(ACCOUNT_KEY(account), key)\n    }\n    this.key = key\n    return key\n  }\n\n  async setItem(key: string, value: string): Promise<void> {\n    // encrypt data\n    const encryptedData = await encryptData(value, this.key)\n\n    // save data to storage\n    await this.storage?.setItem(\n      this.dataKey(key),\n      JSON.stringify(encryptedData)\n    )\n  }\n\n  async setItemT<T>(key: string, value: T): Promise<void> {\n    return this.setItem(key, JSON.stringify(value))\n  }\n\n  async getItem(key: string): Promise<string | null> {\n    try {\n      const encryptedDataStr = await this.storage?.getItem(this.dataKey(key))\n      if (!encryptedDataStr) return null\n\n      const encryptedData: EncryptedData = JSON.parse(encryptedDataStr)\n      const cypher = await decryptData(encryptedData, this.key)\n      return cypher\n    } catch (err) {\n      return null\n    }\n  }\n\n  async getItemT<T>(key: string, defaultValue?: T): Promise<T | null> {\n    const itemStr = await this.getItem(key)\n    if (!itemStr) return defaultValue ?? null\n    return JSON.parse(itemStr) as T\n  }\n\n  async removeItem(key: string): Promise<void> {\n    try {\n      await this.storage?.removeItem(this.dataKey(key))\n    } catch (err) {}\n    return\n  }\n}\n\nexport interface StorageInterface {\n  setItem(\n    key: string,\n    value: string,\n    callback?: (error?: Error) => void\n  ): Promise<void>\n\n  getItem(\n    key: string,\n    callback?: (error?: Error) => void\n  ): Promise<string | null>\n\n  removeItem(key: string, callback?: (error?: Error) => void): Promise<void>\n}\n"]}