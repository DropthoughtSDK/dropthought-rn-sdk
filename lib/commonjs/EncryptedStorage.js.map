{"version":3,"sources":["EncryptedStorage.ts"],"names":["ACCOUNT_KEY_PREFIX","ACCOUNT_KEY","account","EncryptedStorage","constructor","storage","key","dataKey","setAccount","passphrase","SecureKeyStore","get","err","undefined","salt","set","setItem","value","encryptedData","JSON","stringify","setItemT","getItem","encryptedDataStr","parse","cypher","getItemT","defaultValue","itemStr","removeItem"],"mappings":"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","sourcesContent":["import {\n  randomKey,\n  pbkdf2,\n  encryptData,\n  decryptData,\n  EncryptedData,\n} from './crypto-utils'\nimport * as SecureKeyStore from './secure-keystore'\n\nconst ACCOUNT_KEY_PREFIX = '@rn-encrypted-storage:key'\nconst ACCOUNT_KEY = (account: string) => `${ACCOUNT_KEY_PREFIX}:${account}`\n\nexport class EncryptedStorage implements StorageInterface {\n  private account: string\n  private key: string\n  private storage: StorageInterface | null\n\n  constructor(storage: StorageInterface) {\n    this.account = ''\n    this.key = ''\n    this.storage = storage\n  }\n\n  private dataKey(key: string) {\n    return `${ACCOUNT_KEY(this.account)}/${key}`\n  }\n\n  async setAccount(account: string, passphrase: string): Promise<string> {\n    this.account = account\n\n    // get key from store\n    let key\n    try {\n      key = await SecureKeyStore.get(ACCOUNT_KEY(account))\n    } catch (err) {\n      // ignore this error\n      key = undefined\n    }\n\n    if (!key) {\n      const salt = await randomKey(32)\n      key = await pbkdf2(passphrase, salt, 5000, 256)\n      // store key\n      await SecureKeyStore.set(ACCOUNT_KEY(account), key)\n    }\n    this.key = key\n    return key\n  }\n\n  async setItem(key: string, value: string): Promise<void> {\n    // encrypt data\n    const encryptedData = await encryptData(value, this.key)\n\n    // save data to storage\n    await this.storage?.setItem(\n      this.dataKey(key),\n      JSON.stringify(encryptedData)\n    )\n  }\n\n  async setItemT<T>(key: string, value: T): Promise<void> {\n    return this.setItem(key, JSON.stringify(value))\n  }\n\n  async getItem(key: string): Promise<string | null> {\n    try {\n      const encryptedDataStr = await this.storage?.getItem(this.dataKey(key))\n      if (!encryptedDataStr) return null\n\n      const encryptedData: EncryptedData = JSON.parse(encryptedDataStr)\n      const cypher = await decryptData(encryptedData, this.key)\n      return cypher\n    } catch (err) {\n      return null\n    }\n  }\n\n  async getItemT<T>(key: string, defaultValue?: T): Promise<T | null> {\n    const itemStr = await this.getItem(key)\n    if (!itemStr) return defaultValue ?? null\n    return JSON.parse(itemStr) as T\n  }\n\n  async removeItem(key: string): Promise<void> {\n    try {\n      await this.storage?.removeItem(this.dataKey(key))\n    } catch (err) {}\n    return\n  }\n}\n\nexport interface StorageInterface {\n  setItem(\n    key: string,\n    value: string,\n    callback?: (error?: Error) => void\n  ): Promise<void>\n\n  getItem(\n    key: string,\n    callback?: (error?: Error) => void\n  ): Promise<string | null>\n\n  removeItem(key: string, callback?: (error?: Error) => void): Promise<void>\n}\n"]}